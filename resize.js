const fs = require("fs");
const rimraf = require("rimraf");
const sharp = require("sharp");
const minify = require("html-minifier").minify;
const base = "./img";
const template = "index.template.html";
const sizes = [420, 840];
const skip_images = process.argv.includes("--skip-images");
let processed_count = 0;
let images_html = "";

if (!skip_images) {
  sizes.forEach(size => {
    rimraf(`${base}/${size}/*`, err => {
      if (err) {
        console.log(err);
      }
    });
  });
}

fs.readdir(`${base}/full`, (err, files) => {
  if (err) {
    console.log;
    `Couldn't read image files. ${err}`;
  } else {
    const total_files = files.length;
    files.forEach(file => {
      file = file.replace(".jpg", "");
      let sources_html = "";

      sizes.forEach(size => {
        if (!skip_images) {
          setTimeout(() => {
            resize(file, size);
          }, 2000);
        }

        // Add HTML for this size only if not last size
        if (size !== sizes[sizes.length - 1]) {
          sources_html += build_sources_html(size, file);
        }
      });

      // Build <source>s into <a> and <picture> tags for this image
      sharp(`img/full/${file}.jpg`)
        .metadata()
        .then(metadata => {
          output_html(file, sources_html, sizes, [
            metadata.width,
            metadata.height
          ]);
        })
        .catch(err => console.log(err));

      // If this is the final file, build index.html
      if (++processed_count === total_files) {
        save_processed_files();
      }
    });
  }
});

const build_sources_html = (size, file) => {
  return `
          <source
            type="image/webp"
            media="(max-width: ${size})"
            data-srcset="img/${size}/${file}.webp">                      
          <source
            type="image/jpeg"
            media="(max-width: ${size})"
            data-srcset="img/${size}/${file}.jpg">                      
        `;
};

const output_html = (file, sources_html, sizes, dimensions) => {
  const aspect = `${(dimensions[1] / dimensions[0]) * 100}%`;
  const lastSize = sizes[sizes.length - 1];
  // Output HTML for files
  images_html += `<a
                    href="img/full/${file}.jpg"
                    target="_blank">
                    <picture style="padding-top: ${aspect};">
                      ${sources_html}
                    <source
                      type="image/webp"
                      data-srcset="img/${lastSize}/${file}.webp"> 
                    <img class="lazyload" data-src="img/${lastSize}/${file}.jpg">
                    </picture>
                  </a>`;
};

const resize = (file, width) => {
  const image = sharp(`${base}/full/${file}.jpg`);

  // WebP version
  image
    .resize(width)
    .toFormat("webp")
    .toFile(`./img/${width}/${file}.webp`, (err, info) => {
      if (err) {
        console.log(`Uh oh! Couldn't save output file. ${err}`);
      } else {
        console.log(`Saved img/${width}/${file}.webp`);
      }
    });

  // JPG backup
  image
    .resize(width)
    .toFormat("jpg")
    .toFile(`./img/${width}/${file}.jpg`, (err, info) => {
      if (err) {
        console.log(`Uh oh! Couldn't save output file. ${err}`);
      } else {
        console.log(`Saved img/${width}/${file}.jpg`);
      }
    });
};

const save_processed_files = () => {
  fs.readFile(template, "utf-8", (err, data) => {
    if (err) {
      console.log(`Couldn't read ${template}. ${err}`);
    } else {
      const html = data.replace("{{the_content}}", images_html);
      const minified = minify(html, {
        minifyCSS: true,
        html5: true,
        collapseWhitespace: true,
        collapseInlineTagWhitespace: true,
        decodeEntities: true,
        includeAutoGeneratedTags: true,
        removeComments: true
      });
      fs.writeFile("./index.html", minified, written_files);
    }
  });
};

const written_files = () => {
  console.log(`Saved index.html`);
};
